# Урок 6. Принципы построения приложений «чистая архитектура»
## Домашнее задание
Реализовать любые 2 паттерна, прочитать про остальные.
Доделать дз с прошлых семинаров.
Прокси (Proxy): Прокси предоставляет заместитель для другого объекта и управляет доступом к нему. Это может быть полезно для ленивой инициализации объектов, контроля доступа, мониторинга и т. д.

Мост (Bridge): Мост разделяет абстракцию от ее реализации, позволяя им изменяться независимо друг от друга. Этот паттерн используется, когда есть несколько способов расширения классов и когда изменение одного класса не должно влиять на другой.

Фасад (Facade): Фасад предоставляет унифицированный интерфейс к группе интерфейсов подсистемы. Он упрощает работу с сложной системой, предоставляя более простой интерфейс.


Легковес (Flyweight): Этот паттерн используется для оптимизации работы с большим количеством мелких объектов, путем разделения общей части объектов и уменьшения затрат на память.

Заместитель (Proxy): Заместитель предоставляет объект, который выступает в качестве заместителя для другого объекта и контролирует доступ к нему. Это может быть полезно для ленивой инициализации, отложенной загрузки данных и т. д.

По желанию. Разработать полную ERD домена в https://www.dbdesigner.net/. по любому из старых проектов, цель вспомнить о БД.

### Адаптер 
Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

### Мост 
Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.
Паттерн Мост предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.
Абстракция (или интерфейс) — это образный слой управления чем-либо. Он не делает работу самостоятельно, а делегирует её слою реализации (иногда называемому платформой). Абстракцией может выступать графический интерфейс программы (GUI), а реализацией — низкоуровневый код операционной системы (API), к которому графический интерфейс обращается по реакции на действия пользователя.
Абстракция будет делегировать работу одному из объектов реализаций. Причём, реализации можно будет взаимозаменять, но только при условии, что все они будут следовать общему интерфейсу.
Таким образом, вы сможете изменять графический интерфейс приложения, не трогая низкоуровневый код работы с операционной системой. И наоборот, вы сможете добавлять поддержку новых операционных систем, создавая подклассы реализации, без необходимости менять классы графического интерфейса.

Мост позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

Мост — это структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.
Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции. Мост используется, когда нужно разделить абстракцию от ее реализации,чтобы они могли изменяться независимо друг от друга. Это особенно полезно, когда существует несколько способов расширять функциональность классов и эти изменения не должны влиять на другие классы. Мост позволяет связать эти различные реализации, чтобы клиентский код мог работать с абстракцией, не завися от конкретной реализации.

Пример использования паттерна Мост может быть следующим:

Разделение абстракции и реализации: Когда у вас есть иерархия классов, где каждый класс имеет два измерения изменения, можно использовать паттерн Мост. Например, если у вас есть иерархия "Форма" и иерархия "Цвет", паттерн Мост позволит вам комбинировать различные формы с разными цветами без необходимости создания подклассов каждой комбинации.

Управление разнообразием реализаций: Паттерн Мост помогает управлять разнообразием реализаций, позволяя добавлять новые реализации, не затрагивая существующий код абстракции. Например, если у вас есть абстракция "Сообщение" и реализации для разных типов сообщений, вы можете добавить новый тип сообщения, создав новую реализацию, без изменения кода абстракции.

Расширение возможностей системы: Паттерн Мост позволяет расширять возможности системы, добавляя новые абстракции и реализации в независимости друг от друга. Например, если у вас есть абстракция "Транспортное средство" и реализации для разных типов транспорта, вы можете добавить новый тип транспорта или новую функциональность для существующего типа транспорта, не затрагивая существующий код.

### Фасад 

Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку. Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.
Фасад предоставляет быстрый доступ к определённой функциональности подсистемы. Он «знает», каким классам нужно переадресовать запрос, и какие данные для этого нужны.

Пример использования фасада может быть следующим: пользователь взаимодействует с веб-сайтом, который оказывает различные услуги, такие как онлайн-покупки, онлайн-банкинг и т.д. Внутри сайта есть много сложных программных компонентов, подразделений и работ, которые необходимы для обеспечения этих услуг, но пользователь не должен быть знаком с этими деталями, а должен иметь возможность использовать только разработанный интерфейс.

Преимущества использования паттерна Facade включают:

Уменьшение сложности системы: Фасад скрывает сложность внутренних компонентов системы и предоставляет простой и понятный интерфейс для клиентского кода. Это упрощает работу с системой и уменьшает сложность разработки.

Улучшение поддерживаемости: Фасад может служить точкой входа для клиентского кода, что позволяет легко изменять или заменять внутренние компоненты системы без влияния на клиентский код.

Сокрытие деталей реализации: Фасад скрывает детали реализации внутренних компонентов системы, ограничивая доступ клиентского кода только к необходимому функционалу. Это повышает уровень абстракции и упрощает взаимодействие с системой.

Однако, следует быть осторожным с применением паттерна Facade, чтобы не создавать слишком много функционала в одном месте. Если фасад содержит большое количество функций и компонентов, он может стать сам по себе сложным и трудным в поддержке.

### Заместитель 
Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.
Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую

### Легковес 
Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

Паттерн Легковес предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры. Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах. Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием, а оно имеет не так много вариаций.

Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.
Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое. Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый. Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

Вы всегда должны помнить о том, что Легковес применяется в программе, имеющей громадное количество одинаковых объектов. Этих объектов должно быть так много, чтобы они не помещались в доступную оперативную память без ухищрений. Паттерн разделяет данные этих объектов на две части — легковесы и контексты.

В этом примере Легковес помогает сэкономить оперативную память при отрисовке на экране миллионов объектов-деревьев.

Применяйте этот паттерн, когда выполнены все перечисленные условия:

в приложении используется большое число объектов;
из-за этого высоки расходы оперативной памяти;
большую часть состояния объектов можно вынести за пределы их классов;
большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

