"""
Одиночка — это порождающий паттерн проектирования, который гарантирует, 
что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.
Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. 
В этом случае хотелось бы получить старый объект, вместо создания нового.

Предоставляет глобальную точку доступа. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту.
Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.
Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. 
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

Конструктор одиночки должен быть скрыт от клиентов. 
Вызов метода должен стать единственным способом получить объект этого класса.

Вкратце, цель шаблона Singleton заключаются в следующем:
• Обеспечение создания одного и только одного объекта класса
• Предоставление точки доступа для объекта, который является глобальным для программы
• Контроль одновременного доступа к ресурсам, которые являются общими

В Python класс Одиночка можно реализовать по-разному. Возможные способы включают себя базовый класс, декоратор, метакласс.
"""

class SingletonMeta(type):
    """
    Воспользуемся метаклассом
    """
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance


class Singleton(metaclass=SingletonMeta):
    def some_logic(self):
       pass
    """
    Описание какой то логики 
    """


if __name__ == "__main__":
    # Клиентский код.

    s1 = Singleton()
    s2 = Singleton()

    print(s1 is s2)


"""
1. Класс Singleton определяется с помощью частной переменной класса под названием __instance. 
В этой переменной будет храниться единственный экземпляр класса.

2. Метод __new__ переопределяется, чтобы проверить, имеет ли переменная класса __instance значение. 
Если __instance равно None, то класс Singleton создается впервые, поэтому новый экземпляр класса создается с помощью функции 
super().__new__(cls). Функция super() возвращает временный объект суперкласса, который затем используется для вызова его методов.

3.Если __instance не None, это означает, что экземпляр класса Singleton уже был создан, поэтому вместо создания нового экземпляра возвращается существующий.

4. Далее, в блоке кода, который выполняется только если скрипт запущен напрямую (if name == "main"),
создаются два экземпляра класса Singleton и сохраняются в переменные s1 и s2. 
Затем происходит сравнение s1 и s2 по оператору "==", и результат выводится на экран. 
Если результат True, то это означает, что обе переменные ссылаются на один и тот же экземпляр класса,
и класс Singleton работает правильно
"""